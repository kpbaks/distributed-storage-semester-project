syntax = "proto3";

message storedata_request
{
    string filename = 1;
}

message getdata_request
{
    string filename = 1;
}

message fragment_status_request
{
    string fragment_name = 1;
}

message StorageNode
{
	string ip = 1;
	int32 port = 2;
}

// Task 1.1 ---------------------------------------------------------------------------------------
message Task11Request
{
	string file_uuid = 1; // The UUID of the file to be stored
	bytes file_data = 2; // The file data
}

message Task11Response
{
	bool success = 1; // true if the file was successfully stored
}

// Task 1.2 ---------------------------------------------------------------------------------------

message Task12Request
{
	uint64 file_id = 1; // the primary key of the file from the `file_metadata` table
	bytes file_data = 2; // the file data
	// The REST server will construct this list.
	// When a storage node receives this request, it will remove itself from the list.
	// The list will be empty when the request reaches the last storage node.
	repeated StorageNode nodes_to_forward_to = 3;
}

message Task12Response
{
	bool success = 1; // true if the file was successfully stored
}


message fhdfs_storedata_request
{
	uint64 stripe_id = 1;
	uint64 fragment_id = 2;
	// The REST server will construct this list.
	// When a storage node receives this request, it will remove itself from the list.
	// The list will be empty when the request reaches the last storage node.
	repeated StorageNode nodes_to_forward_to = 3;
	/* bytes stripe = 4; */
}


message HeartBeatResponse
{
	string uid = 1;
	bool is_alive = 2;
}

message fhdfs_storedata_response
{
	bool success = 1;
	repeated string storage_ids = 2;
}

// ------------------------------------------------------------------------------------------------

message fragment_status_response
{
    string fragment_name = 1;
    bool is_present = 2;
    string node_id = 3;
    int32 count = 4;
}

enum request_type
{
    FRAGMENT_STATUS_REQ = 0;
    FRAGMENT_DATA_REQ = 1;
    STORE_FRAGMENT_DATA_REQ = 2;
    RECODE_FRAGMENTS_REQ = 3;
}

// This message is sent in the first frame of the request,
// so the other side knows what format to expect in the second frame
message header
{
    request_type request_type = 1;
}

message recode_fragments_request
{
    string fragment_name = 1;
    int32 symbol_count = 2;
    int32 output_fragment_count = 3;
}

