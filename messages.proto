syntax = "proto3";

// message storedata_request
// {
//     string filename = 1;
// }

// message getdata_request
// {
//     string filename = 1;
// }

// message fragment_status_request
// {
//     string fragment_name = 1;
// }

message StorageNode
{
	string ipv4 = 1;
	int32 port_get_data = 2;
	int32 port_store_data = 3;
	string uid = 4;
}

message StorageNodeAdvertisementRequest
{
	StorageNode node = 1;
	string friendly_name = 2;
}

message StorageNodeAdvertisementResponse
{
	bool success = 1;
}

message GetDataRequest
{
	string file_uid = 1; // The UUID of the file to be retrieved
}

message GetDataResponse
{
	bool success = 1; // true if the file was successfully retrieved
	bytes file_data = 2; // The file data
}

message StoreDataRequest
{
	string file_uid = 1; // The UUID of the file to be stored
	bytes file_data = 2; // The file data
}

message StoreDataResponse
{
	bool success = 1; // true if the file was successfully stored
}

message DelegateStoreDataRequest
{
	string file_uid = 1; // The UUID of the file to be stored
	bytes file_data = 2; // The file data
	repeated StorageNode nodes_to_forward_to = 3; // The list of nodes to forward the request to
}

message EncodeAndForwardFragmentsRequest
{
	string file_uid = 1; // The UUID of the file to be stored
	bytes file_data = 2; // The file data
	repeated StorageNode nodes_to_forward_to = 3; // The list of nodes to forward the request to
	uint32 l = 4; // The number of fragments to encode
}

message EncodeAndForwardFragmentsResponse
{
	map<string, StorageNode> fragment_uids_to_storage_nodes = 1;
	double time_rs_encode = 2;
}

message GetFragmentsAndDecodeThemRequest
{
	uint32 l = 1; // The number of fragments to encode
	uint64 filesize = 2; // The size of the file
	map<string, StorageNode> fragment_uids_to_storage_nodes = 3;
}

message DelegateStoreDataResponse
{
	bool success = 1; // true if the file was successfully stored
	double time_replication = 2;
}

enum MsgType
{
	GET_DATA_REQUEST = 0;
	GET_DATA_RESPONSE = 1;
	STORE_DATA_REQUEST = 2;
	STORE_DATA_RESPONSE = 3;
	DELEGATE_STORE_DATA_REQUEST = 4;
	DELEGATE_STORE_DATA_RESPONSE = 5;
	STORAGE_NODE_ADVERTISEMENT_REQUEST = 6;
	STORAGE_NODE_ADVERTISEMENT_RESPONSE = 7;
	ENCODE_AND_FORWARD_FRAGMENTS_REQUEST = 8;
	ENCODE_AND_FORWARD_FRAGMENTS_RESPONSE = 9;
	GET_FRAGMENTS_AND_DECODE_THEM_REQUEST = 10;
}

message Message
{
	MsgType type = 1;
	oneof payload
	{
		GetDataRequest get_data_request = 2;
		GetDataResponse get_data_response = 3;
		StoreDataRequest store_data_request = 4;
		StoreDataResponse store_data_response = 5;
		DelegateStoreDataRequest delegate_store_data_request = 6;
		DelegateStoreDataResponse delegate_store_data_response = 7;
		StorageNodeAdvertisementRequest storage_node_advertisement_request = 8;
		StorageNodeAdvertisementResponse storage_node_advertisement_response = 9;
		EncodeAndForwardFragmentsRequest encode_and_forward_fragments_request = 10;
		EncodeAndForwardFragmentsResponse encode_and_forward_fragments_response = 11;
		GetFragmentsAndDecodeThemRequest get_fragments_and_decode_them_request = 12;
	}
}

// ------------------------------------------------------------------------------------------------

// message fragment_status_response
// {
//     string fragment_name = 1;
//     bool is_present = 2;
//     string node_id = 3;
//     int32 count = 4;
// }

// enum request_type
// {
//     FRAGMENT_STATUS_REQ = 0;
//     FRAGMENT_DATA_REQ = 1;
//     STORE_FRAGMENT_DATA_REQ = 2;
//     RECODE_FRAGMENTS_REQ = 3;
// }

// // This message is sent in the first frame of the request,
// // so the other side knows what format to expect in the second frame
// message header
// {
//     request_type request_type = 1;
// }

// message recode_fragments_request
// {
//     string fragment_name = 1;
//     int32 symbol_count = 2;
//     int32 output_fragment_count = 3;
// }

